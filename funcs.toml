[domains]
acos = [-1.0, 1.0]
acosh = [1.0, 1000.0]
asin = [-1.0, 1.0]
asinh = [-100.0, 100.0]
atan = [-100.0, 100.0]
atanh = [-1.0, 1.0]
bessel_I0 = [0.1, 30.0]
bessel_I1 = [0.1, 30.0]
bessel_I2 = [0.1, 30.0]
bessel_J0 = [0.1, 30.0]
bessel_J1 = [0.1, 30.0]
bessel_J2 = [0.1, 30.0]
bessel_K0 = [0.1, 30.0]
bessel_K1 = [0.1, 30.0]
bessel_K2 = [0.1, 30.0]
bessel_Y0 = [0.1, 30.0]
bessel_Y1 = [0.1, 30.0]
bessel_Y2 = [0.1, 30.0]
bessel_j0 = [0.1, 30.0]
bessel_j1 = [0.1, 30.0]
bessel_j2 = [0.1, 30.0]
bessel_y0 = [0.1, 30.0]
bessel_y1 = [0.1, 30.0]
bessel_y2 = [0.1, 30.0]
cos = [0.0, 6.283]
cos_pi = [0.0, 2.0]
cosh = [0.0, 1.0]
digamma = [0.0, 1.0]
erf = [-1.0, 1.0]
erfc = [-1.0, 1.0]
exp = [-1.0, 1.0]
exp10 = [-1.0, 1.0]
exp2 = [-1.0, 1.0]
#hank103 = [0.0, 10.0, .ilbound = 0.0, .iubound = 10.0]
hermite_0 = [0.0, 10.0]
hermite_1 = [0.0, 10.0]
hermite_2 = [0.0, 10.0]
hermite_3 = [0.0, 10.0]
lgamma = [0.0, 10.0]
log = [0.0, 10.0]
log10 = [0.0, 10.0]
log2 = [0.0, 10.0]
memcpy = [0.0, 1.0]
memset = [0.0, 1.0]
ndtri = [0.0, 1.0]
pow13 = [0.0, 1.0]
"pow3.5" = [0.0, 1.0]
riemann_zeta = [0.0, 10.0]
rsqrt = [0.0, 10.0]
sin = [0.0, 6.283]
sin_pi = [0.0, 2.0]
sinc = [0.0, 6.283]
sinc_pi = [0.0, 2.0]
sinh = [0.0, 2.0]
sqrt = [0.0, 10.0]
tan = [0.0, 6.283]
tanh = [-1.0, 1.0]
tgamma = [-0.0, 1.0]

[stl]
types = ["float", "double"]
instructions = ["x86_64"]

[stl.calltemplates]
sin = "std::sin(x)"
cos = "std::cos(x)"
tan = "std::tan(x)"
asin = "std::asin(x)"
acos = "std::acos(x)"
atan = "std::atan(x)"
sinh = "std::sinh(x)"
cosh = "std::cosh(x)"
tanh = "std::tanh(x)"
asinh = "std::asinh(x)"
acosh = "std::acosh(x)"
atanh = "std::atanh(x)"
tgamma = "std::tgamma(x)"
lgamma = "std::lgamma(x)"
erf = "std::erf(x)"
erfc = "std::erfc(x)"
log = "std::log(x)"
log2 = "std::log2(x)"
log10 = "std::log10(x)"
exp = "std::exp(x)"
exp2 = "std::exp2(x)"
exp10 = "std::exp10(x)"
sqrt = "std::sqrt(x)"
"pow3.5" = "std::pow(x, 3.5)"
pow13 = "std::pow(x, 13)"

[stl.overrides]
memset = "[](const {stype} *src, {stype} *dst, size_t N) {{ std::memset(dst, 0, N * sizeof({stype})); }}"
memcpy = "[](const {stype} *src, {stype} *dst, size_t N) {{ std::memset(dst, src, N * sizeof({stype})); }}"

[af]
types = ["float", "double"]
instructions = ["avx2", "avx512"]

[af.calltemplates]
sin = "sin(x)"
cos = "cos(x)"
tan = "tan(x)"
asin = "asin(x)"
acos = "acos(x)"
atan = "atan(x)"
sinh = "sinh(x)"
cosh = "cosh(x)"
tanh = "tanh(x)"
asinh = "asinh(x)"
acosh = "acosh(x)"
atanh = "atanh(x)"
tgamma = "tgamma(x)"
lgamma = "lgamma(x)"
erf = "erf(x)"
erfc = "erfc(x)"
log = "log(x)"
log2 = "log2(x)"
log10 = "log10(x)"
exp = "exp(x)"
exp2 = "exp2(x)"
exp10 = "exp10(x)"
sqrt = "sqrt(x)"
"pow3.5" = "pow(x, 3.5)"
pow13 = "pow(x, 13)"
memcpy = "x"
memset = "{vectype}{{0.0}}"

[eigen]
types = ["float", "double"]
instructions = ["unknown"]

[eigen.overrides]
cos = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
sin = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
tan = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
cosh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
sinh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
tanh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
exp = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
log = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
log10 = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
"pow3.5" = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).pow(3.5); }}"
pow13 = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).pow(13); }}"
asin = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
acos = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
atan = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
asinh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
acosh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
atanh = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
erf = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
erfc = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
lgamma = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
digamma = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
ndtri = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
sqrt = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
rsqrt = "[](const {stype} *src, {stype} *dst, size_t N) {{ Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N) = Eigen::Map<Eigen::ArrayX<{stype}>>(dst, N).{func}(); }}"
